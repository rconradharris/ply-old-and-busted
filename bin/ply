#!/usr/bin/env python
"""
# create a new patch
$ ply new feature1
    This creates a new branch called 001_feature1.
    It then applies all previous commits and commits them

# save a patch to the patch repo (after you've commited to the patch branch)
$ ply save

# Create a branch called development, and then apply each patch
# if the branch already exists, it is overwritten!
$ ply apply development
"""
import functools
import glob
import os
import sys

from ply import git
from ply import utils


class PathNotFound(Exception):
    pass


def die(msg):
    print msg
    sys.exit(1)


def usage():
    die("usage: ply <cmd>")


def find_ply_path(path):
    """Looks for .ply directory in the current directory, then any parent
    directories.

    If not found, raises a PathNotFound exception.
    """
    for cur_path in utils.walk_up_path(path):
        ply_path = os.path.join(cur_path, '.ply')
        if os.path.exists(ply_path):
            return ply_path
    raise PathNotFound


def do_init():
    """Initialize patch repo directory structure.

    config
    patches/
        .gitkeep
    """
    # FIXME: patches directory may not need to exist
    os.mkdir('patches')
    join = functools.partial(os.path.join, 'patches')
    utils.write_empty_file(join('.gitkeep'))
    # TODO: commit "Initializing Patch Repo"


def do_link(*args):
    """Link a working repo to a patch repo.

    Creates a .ply directory to hold ply state.
    """
    if not args:
        die("ply link <patch-repo-path>")

    patch_repo_path = args[0]
    try:
        link(patch_repo_path)
    except PathNotFound:
        die("'%s' does not exist" % patch_repo_path)


def link(patch_repo_path):
    """Link a working repo to a patch repo.

    Creates a .ply directory to hold ply state.
    """
    patch_repo_path = utils.fixup_path(patch_repo_path)

    if not os.path.exists(patch_repo_path):
        raise PathNotFound(patch_repo_path)

    # TODO: verify that this is a git repo
    # TODO: verify that .ply directory doesn't already exist
    os.mkdir('.ply')
    join = functools.partial(os.path.join, '.ply')

    utils.write_file(join('patch_repo'), patch_repo_path)


def get_patch_repo_path(path):
    """Return the patch repo path for the `path` within a working repo."""
    ply_path = find_ply_path(path)
    with open(os.path.join(ply_path, 'patch_repo'), 'r') as f:
        patch_repo_path = f.read().strip()
    return patch_repo_path


def write_patch_head(ply_path, patch_num):
    """Write out a counter which keeps track of the last successfully applied
    patch.
    """
    with open(os.path.join(ply_path, 'PATCH_HEAD'), 'w') as f:
        f.write("%d\n" % patch_num)


def get_patch_head(ply_path):
    with open(os.path.join(ply_path, 'PATCH_HEAD'), 'r') as f:
        patch_num = int(f.read().strip())
        return patch_num


def do_status():
    print "Patch Repo: %s" % get_patch_repo_path(os.getcwd())


def do_patches():
    patch_repo_path = get_patch_repo_path(os.getcwd())
    for patch_path in get_all_patch_paths(patch_repo_path):
        print patch_path


def do_apply(branch_name):
    cwd = os.getcwd()
    ply_path = find_ply_path(cwd)
    patch_repo_path = get_patch_repo_path(cwd)
    apply_to_new_branch(ply_path, patch_repo_path, branch_name,
                        create_and_reset=True)


def apply_to_new_branch(ply_path, patch_repo_path, branch_name, create=False,
        create_and_reset=False):
    """Create a branch and apply patches to it."""
    git.checkout(branch_name, create=create, create_and_reset=create_and_reset)
    apply_all_patches(ply_path, patch_repo_path)


def get_patch_num_from_patch_name(patch_name):
    patch_prefix = patch_name.split('-', 1)[0]
    patch_num = int(patch_prefix)
    return patch_num


def apply_all_patches(ply_path, patch_repo_path):
    write_patch_head(ply_path, 0)
    apply_patches(ply_path, patch_repo_path)


def apply_patches(ply_path, patch_repo_path, start_patch_num=1):
    for patch_path in get_all_patch_paths(patch_repo_path):
        filename = os.path.basename(patch_path)
        patch_num = get_patch_num_from_patch_name(filename)
        if patch_num < start_patch_num:
            continue

        git.am(patch_path, three_way_merge=True)
        write_patch_head(ply_path, patch_num)


def do_resolve():
    """
    Resolve a corrupted patch.

    Steps:

        1. Fix the conflicting lines.
        2. Add the files to the index.
        3. Run ply resolve
            a. This runs git am --resolve
            b. Creates revised patch
            c. Copies this revised patch over to patch repo.
            d. Continues applying the rest of the patches
    """
    cwd = os.getcwd()
    ply_path = find_ply_path(cwd)
    patch_repo_path = get_patch_repo_path(cwd)
    resolve(ply_path, patch_repo_path)


def resolve(ply_path, patch_repo_path):
    git.am(resolved=True)

    last_patch_num = get_patch_head(ply_path)
    this_patch_num = last_patch_num + 1

    generate_and_commit_to_patch_repo(
            patch_repo_path, start_number=this_patch_num)

    next_patch_num = this_patch_num + 1
    apply_patches(ply_path, patch_repo_path, start_patch_num=next_patch_num)


def get_all_patch_paths(patch_repo_path):
    patches_path = patch_repo_path = os.path.join(patch_repo_path, 'patches')
    patches_glob = os.path.join(patches_path, "*.patch")

    for path in glob.iglob(patches_glob):
        yield path


def do_save():
    patch_repo_path = get_patch_repo_path(os.getcwd())
    save(patch_repo_path)


def get_current_branch_name():
    ref_name = git.symbolic_ref('HEAD', quiet=True)
    current_branch_name = ref_name.replace('refs/heads/', '')
    return current_branch_name


def save(patch_repo_path):
    """Writes out last git commit to a patch file in the patch repo.

    """
    # TODO: add guard to ensure that new commit differs from last master
    # commit and last applied patch. Forgetting to commit, will be a common
    # mistake!

    patch_name = get_current_branch_name()
    patch_num = get_patch_num_from_patch_name(patch_name)

    # TODO: write these patch files to the ply directory
    # NOTE: for now we're assuming we're dealing with 1 patch (could it be
    # more?)
    generate_and_commit_to_patch_repo(patch_repo_path, start_number=patch_num)


def generate_and_commit_to_patch_repo(patch_repo_path, start_number=None):
    # NOTE: assume we're dealing with one patch for now
    filenames = git.format_patch(1, start_number=start_number)

    patches_path = os.path.join(patch_repo_path, 'patches')
    for filename in filenames:
        os.rename(filename, os.path.join(patches_path, filename))

    # TODO: generate a different commit message based on whether this is the
    # original patch commit, or resolving a conflict
    with utils.temporary_chdir(patches_path):
        for filename in filenames:
            git.add(filename)
        git.commit("Adding or updating %d" % start_number)


def make_next_patch_name(patch_repo_path, name):
    next_patch_num = get_max_patch_num(patch_repo_path) + 1
    return "%04d-%s" % (next_patch_num, utils.slugify(name))


def get_max_patch_num(patch_repo_path):
    patch_paths = list(get_all_patch_paths(patch_repo_path))
    if not patch_paths:
        return 0

    last_patch_path = patch_paths[-1]
    filename = os.path.basename(last_patch_path)
    patch_num = get_patch_num_from_patch_name(filename)
    return patch_num


def do_create(name):
    # TODO: perhaps name should be optional, since it won't be used; just a
    # convenience so you end up with a human-friendly branch name
    cwd = os.getcwd()
    ply_path = find_ply_path(cwd)
    patch_repo_path = get_patch_repo_path(cwd)
    create_new_patch_branch(ply_path, patch_repo_path, name)


def create_new_patch_branch(ply_path, patch_repo_path, name):
    """
    1. Create a topic branch with the patch name
    2. Apply all of the patches
    3. Commit the patches into git
    """
    patch_name = make_next_patch_name(patch_repo_path, name)
    apply_to_new_branch(ply_path, patch_repo_path, patch_name, create=True)


def main():
    if len(sys.argv) < 2:
        usage()

    cmd = sys.argv[1]
    func = globals().get('do_%s' % cmd)
    if func:
        func(*sys.argv[2:])
    else:
        die("command '%s' not found" % cmd)


if __name__ == "__main__":
    main()
