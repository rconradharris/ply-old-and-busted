#!/usr/bin/env python
import os
import sys

import ply
from ply import git
from ply import utils


def die(msg):
    print msg
    sys.exit(1)


def usage():
    die("usage: ply <cmd>")


def do_apply(branch_name):
    cwd = os.getcwd()
    ply_path = ply.find_ply_path(cwd)
    patch_repo_path = ply.get_patch_repo_path(cwd)
    ply.apply_to_new_branch(ply_path, patch_repo_path, branch_name,
                            create_and_reset=True)


def do_create(name):
    # TODO: perhaps name should be optional, since it won't be used; just a
    # convenience so you end up with a human-friendly branch name
    cwd = os.getcwd()
    ply_path = ply.find_ply_path(cwd)
    patch_repo_path = ply.get_patch_repo_path(cwd)
    ply.create_new_patch_branch(ply_path, patch_repo_path, name)


def do_link(*args):
    """Link a working repo to a patch repo.

    Creates a .ply directory to hold ply state.
    """
    if not args:
        die("ply link <patch-repo-path>")

    patch_repo_path = args[0]
    try:
        ply.link(patch_repo_path)
    except ply.PathNotFound:
        die("'%s' does not exist" % patch_repo_path)


def do_resolve():
    """
    Resolve a corrupted patch.

    Steps:

        1. Fix the conflicting lines.
        2. Add the files to the index.
        3. Run ply resolve
            a. This runs git am --resolve
            b. Creates revised patch
            c. Copies this revised patch over to patch repo.
            d. Continues applying the rest of the patches
    """
    cwd = os.getcwd()
    ply_path = ply.find_ply_path(cwd)
    patch_repo_path = ply.get_patch_repo_path(cwd)
    ply.resolve(ply_path, patch_repo_path)


def do_save():
    patch_repo_path = ply.get_patch_repo_path(os.getcwd())
    ply.save(patch_repo_path)


def main():
    if len(sys.argv) < 2:
        usage()

    cmd = sys.argv[1]
    func = globals().get('do_%s' % cmd)
    if func:
        func(*sys.argv[2:])
    else:
        die("command '%s' not found" % cmd)


if __name__ == "__main__":
    main()
